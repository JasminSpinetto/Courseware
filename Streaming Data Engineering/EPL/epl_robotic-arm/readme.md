# An example of an Exam question solved in EPL

## Introductions

Suppose you want to monitor a group of robots used for picking and placing goods in an Industry 4.0 storehouse with a stream processing engine.
Each robotic arm sends events reporting its status: 

* ready to pick a good, 
* good grasped, 
* moving a good, 
* placing a good, 
* moving without any goods. 

Several Force-Sensing Resistors measure the stress levels of the robotic arm. The robot is safely operating if the stress level is between 0 and 6. A controller should raise a warning if it is between 7 and 8. A controller should stop the robot if it is above 9.

## Questions & answers

### Q1

Propose how to model the streaming data generated by the robotic arms.

#### Some thinking

There are two forces: the **reality** and the **pragmatism**

The **reality** pushes for the most detailed model. Notably, the text above may imply that the Force-Sensing Resistors are independent sensors that send their own events separately from the arms. So one may be tempted to propose the following modeling.

```
create schema RoboticArm(id int, status string); 
create schema ForceSensingResistors(idArm string, stressLvl int)
```

The **pragmatism**, on the contrary, pushes for the minimum model that allows the continuous process of the data so to satisfy the needs presented in the following point (from Q2 to Q5). This is more efficient because we avoid joins betweens events. If you read them, you may understand that they are possible also with a much simpler model:

```
create schema RoboticArm( id string, status string, stressLevel int );
```

The rest of the proposed solution **follow**s **the pragmatic approach**.

#### Best practices

As a best practice, I recommend **writing down a portion of the stream** modeled according to your design choice.

For instance:

```
RoboticArm={id="1", status="ready", stressLevel=0} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="goodGrasped", stressLevel=1} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="movingGood", stressLevel=7} 
RoboticArm={id="2", status="ready", stressLevel=0} 
t=t.plus(1 seconds) 
RoboticArm={id="2", status="goodGrasped", stressLevel=5} 
t=t.plus(1 seconds) 
RoboticArm={id="2", status="movingGood", stressLevel=9} 
t=t.plus(5 seconds) 
RoboticArm={id="2", status="placingGood", stressLevel=3} 
RoboticArm={id="1", status="placingGood", stressLevel=3} 
t=t.plus(4 seconds) 
RoboticArm={id="1", status="moving", stressLevel=2} 
RoboticArm={id="2", status="moving", stressLevel=1} 
t=t.plus(3 seconds) 
RoboticArm={id="1", status="ready", stressLevel=0} 
RoboticArm={id="2", status="ready", stressLevel=0} 
t=t.plus(1 seconds)
RoboticArm={id="1", status="ready", stressLevel=0} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="goodGrasped", stressLevel=1} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="movingGood", stressLevel=7} 
RoboticArm={id="2", status="ready", stressLevel=0} 
t=t.plus(1 seconds) 
RoboticArm={id="2", status="goodGrasped", stressLevel=5} 
t=t.plus(1 seconds) 
RoboticArm={id="2", status="movingGood", stressLevel=9} 
t=t.plus(5 seconds) 
RoboticArm={id="2", status="placingGood", stressLevel=3} 
RoboticArm={id="1", status="placingGood", stressLevel=3} 
t=t.plus(4 seconds) 
RoboticArm={id="1", status="moving", stressLevel=2} 
RoboticArm={id="2", status="moving", stressLevel=1} 
t=t.plus(3 seconds) 
RoboticArm={id="1", status="ready", stressLevel=0} 
RoboticArm={id="2", status="ready", stressLevel=0} 
t=t.plus(1 seconds)
```

Another best practice is always to **state your assumptions**:

* The arm sends an event only when its status changes.
* The status can only appear in the order listed in the text above and with no values different from the one stated.
* If an arm stops due to a fault, it stops sending events. Whenever I receive a continuous flow of events, it means that the arm is active.
* When an arm restarts after a fault, it is always in the status ready.
* The stress level in each event is the maximum the arm experienced between the reported status and the previous one (for coherence with question Q2). Stress doesn't significantly change during the movement of one single status (this means we can associate a single stress level to each event).

### Q2 

Declare a continuous query that emits the maximum stress for each arm.

#### Solution

```
@Name("Q2") 
SELECT id, max(stressLevel) \\ you want output in this order
FROM RoboticArm \\get data from this stream
GROUP BY id; \\distinguish data for each RoboticArm
```
Each event triggers the query. When the query is triggered, it outputs for the ID of that event the max(stressLevel) reached until that point in time by that specific RoboticArm.
### Q3 

Declare a continuous query that emits the average stress level between a pick (status==goodGrasped) and a place (status==placingGood). 

HINT: Sometimes you cannot compute an average using the aggregate operator `avg`. in this case, for example, there's no "StressLevel" schema to be queried. We need address it passing through the RoboticArm schema.

#### Solution

```
@Name("E3") 
SELECT a.id, (a.stressLevel + b.stressLevel + c.stressLevel) / 3
FROM pattern [ 
	every 	a=RoboticArm(status="goodGrasped") -> 
		  	b=RoboticArm(id = a.id, status="movingGood") ->
		  	c=RoboticArm(id = a.id, status="placingGood")  ];
```
Inserting the "id" inside the pattern allows us to do a self join between events corresponding to the SAME arm. 

### Q4

Declare a continuous query that returns the robotic arms that, 

* in less than 10 second,
* picked a good while safely operating,
* moved it while the controller was raising a warning, and
* placed it while safely operating again.

#### Solution

```
@Name("E4") 
insert into warning
SELECT a.id AS arm
FROM pattern [ 
	every	a=RoboticArm(status="goodGrasped", stressLevel < 7) ->
			(
				b=RoboticArm(id = a.id, status="movingGood", stressLevel > 6 and stressLevel < 9) ->
				c=RoboticArm(id = a.id, status="placingGood", stressLevel < 7) 
			)
			where timer:within(10 seconds)
		] ;
```
The brackets are needed to specify that we want the timer to start counting from the matching of 'a'. It wants both b and c to happen before 10 seconds. If it goes above 10 seconds, it doesn't even look for events b and/or c. 
### Q5

Declare a continuous query that monitors the results of the previous one (i.e., Q4) and counts how many times each robotic arm is present in the stream over a window of 10 seconds, updating the counting every 2 seconds.

#### Solution

Add "insert into warning" in Q4.
```
@Name("Q5") 
select arm, count(*)
from warning.win:time(10 sec)
group by arm
output last every 2 sec;
```
We use a logical hopping window because we want to output every 2 seconds.

We choose last but also snapshot would be okay. 

## Bonus content

### relaxing assumptions

#### What if the arm does not send an event only when it changes the status?

for instance, it may report moving goods multiple times, such as in 

```
RoboticArm={id="1", status="ready", stressLevel=0} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="goodGrasped", stressLevel=1} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="movingGood", stressLevel=7} 
RoboticArm={id="2", status="ready", stressLevel=0} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="movingGood", stressLevel=7} 
RoboticArm={id="2", status="goodGrasped", stressLevel=5} 
t=t.plus(1 seconds) 
RoboticArm={id="2", status="movingGood", stressLevel=9} 
t=t.plus(5 seconds) 
RoboticArm={id="2", status="placingGood", stressLevel=3} 
RoboticArm={id="1", status="placingGood", stressLevel=3} 
t=t.plus(4 seconds) 
RoboticArm={id="1", status="moving", stressLevel=2} 
RoboticArm={id="2", status="moving", stressLevel=1} 
t=t.plus(3 seconds) 
RoboticArm={id="1", status="ready", stressLevel=0} 
RoboticArm={id="2", status="ready", stressLevel=0} 
t=t.plus(1 seconds)
```

Is the Q4 solution still valid? Shall we add a new `every` clause somewhere?

Adding `every` in front of `b=RoboticArm(id = a.id, status="movingGood", stressLevel > 6 and stressLevel < 9)` makes a difference

```
@Name("E4.every") 
insert into warning
SELECT a.id 
FROM pattern [ 
	every	a=RoboticArm(status="goodGrasped", stressLevel < 7) -> 
			(  
				every b=RoboticArm(id = a.id, status="movingGood", stressLevel > 6 and stressLevel < 9) ->
				c=RoboticArm(id = a.id, status="placingGood", stressLevel < 7) 
			)
			where timer:within(10 seconds)
		] ;
```

#### What if the control system sends stop events?

Let's make the alternative assumption that:

* The control system sends a stop event when an arm has a fault.
* The arms restart after a fault in the status they were before the fault. 

We declare an extra event type

```
create schema Stop( id string);
```

Hereafter, there is a data stream that contains `Stop` events, 

```
RoboticArm={id="1", status="ready", stressLevel=0} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="goodGrasped", stressLevel=1} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="movingGood", stressLevel=7} 
RoboticArm={id="2", status="ready", stressLevel=0} 
t=t.plus(1 seconds) 
RoboticArm={id="2", status="goodGrasped", stressLevel=5} 
t=t.plus(1 seconds) 
RoboticArm={id="2", status="movingGood", stressLevel=9} 
t=t.plus(2 seconds) 
Stop={id="1"}
t=t.plus(3 seconds) 
RoboticArm={id="2", status="placingGood", stressLevel=3} 
RoboticArm={id="1", status="placingGood", stressLevel=3} 
t=t.plus(4 seconds) 
RoboticArm={id="1", status="moving", stressLevel=2} 
RoboticArm={id="2", status="moving", stressLevel=1} 
t=t.plus(3 seconds) 
RoboticArm={id="1", status="ready", stressLevel=0} 
RoboticArm={id="2", status="ready", stressLevel=0} 
t=t.plus(1 seconds)
```

In that case, Q4 may be updated as follows to avoid creating a warning if the arm stops while moving.

```
@Name("Q4.andnot") 
insert into warning
SELECT a.id 
FROM pattern [ 
	every	a=RoboticArm(status="goodGrasped", stressLevel < 7) -> 
			(  every
				b=RoboticArm(id = a.id, status="movingGood", stressLevel > 6 and stressLevel < 9) ->
				c=RoboticArm(id = a.id, status="placingGood", stressLevel < 7) and not Stop(id = a.id)
			)
			where timer:within(10 seconds)
		] ;
```

NOTE: If you remove the Stop event, `E4.andnot` will match once. With the Stop event, it does not match.

