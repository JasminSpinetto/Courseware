# An example of an Exam question solved in EPL

## Introductions

Suppose you want to monitor a group of robots used for picking and placing goods in an Industry 4.0 storehouse with a stream processing engine.
Each robotic arm sends events reporting its status: 

* ready to pick a good, 
* good grasped, 
* moving a good, 
* placing a good, 
* moving without any goods. 

Several Force-Sensing Resistors measure the stress levels of the robotic arm. The robot is safely operating if the stress level is between 0 and 6. A controller should raise a warning if it is between 7 and 8. A controller should stop the robot if it is above 9.

## Questions & answers

### Q1

Propose how to model the streaming data generated by the robotic arms.

#### Some thinking

There are two forces: the **reality** and the **pragmatism**

The **reality** pushes for the most detailed model. Notably, the text above may imply that the Force-Sensing Resistors are independent sensors that send their own events separately from the arms. So one may be tempted to propose the following modeling.

```
create schema RoboticArm(id int, status string); 
create schema ForceSensingResistors(idArm string, stressLvl int)
```

The **pragmatism**, on the contrary, pushes for the minimum model that allows the continuous process of the data so to satisfy the needs presented in the following point (from Q2 to Q5). If you read them, you may understand that they are possible also with a much simpler model:

```
create schema RoboticArm( id string, status string, stressLevel int );
```

The rest of the proposed solution **follow**s **the pragmatic approach**.

#### Best practices

As a best practice, I recommend **writing down a portion of the stream** modeled according to your design choice.

For instance:

```
RoboticArm={id="1", status="ready", stressLevel=0} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="goodGrasped", stressLevel=1} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="movingGood", stressLevel=7} 
RoboticArm={id="2", status="ready", stressLevel=0} 
t=t.plus(1 seconds) 
RoboticArm={id="2", status="goodGrasped", stressLevel=5} 
t=t.plus(1 seconds) 
RoboticArm={id="2", status="movingGood", stressLevel=9} 
t=t.plus(5 seconds) 
RoboticArm={id="2", status="placingGood", stressLevel=3} 
RoboticArm={id="1", status="placingGood", stressLevel=3} 
t=t.plus(4 seconds) 
RoboticArm={id="1", status="moving", stressLevel=2} 
RoboticArm={id="2", status="moving", stressLevel=1} 
t=t.plus(3 seconds) 
RoboticArm={id="1", status="ready", stressLevel=0} 
RoboticArm={id="2", status="ready", stressLevel=0} 
t=t.plus(1 seconds)
RoboticArm={id="1", status="ready", stressLevel=0} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="goodGrasped", stressLevel=1} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="movingGood", stressLevel=7} 
RoboticArm={id="2", status="ready", stressLevel=0} 
t=t.plus(1 seconds) 
RoboticArm={id="2", status="goodGrasped", stressLevel=5} 
t=t.plus(1 seconds) 
RoboticArm={id="2", status="movingGood", stressLevel=9} 
t=t.plus(5 seconds) 
RoboticArm={id="2", status="placingGood", stressLevel=3} 
RoboticArm={id="1", status="placingGood", stressLevel=3} 
t=t.plus(4 seconds) 
RoboticArm={id="1", status="moving", stressLevel=2} 
RoboticArm={id="2", status="moving", stressLevel=1} 
t=t.plus(3 seconds) 
RoboticArm={id="1", status="ready", stressLevel=0} 
RoboticArm={id="2", status="ready", stressLevel=0} 
t=t.plus(1 seconds)
```

Another best practice is always to **state your assumptions**:

* The arm sends an event only when its status changes.
* The status can only appear in the order listed in the text above.
* If an arm stops due to a fault, it stops sending events.
* When an arm restarts after a fault, it is always in the status ready.
* The stress level in each event is the maximum the arm experienced between the reported status and the previous one (for coherence with question Q2).

### Q2 

Declare a continuous query that emits the maximum stress for each arm.

#### Solution

```
@Name("Q2") 
SELECT id, max(stressLevel) 
FROM RoboticArm 
GROUP BY id;
```

### Q3 

Declare a continuous query that emits the average stress level between a pick (status==goodGrasped) and a place (status==placingGood). 

HINT: Sometimes you cannot compute an average using the aggregate operator `avg`

#### Solution

```
@Name("E3") 
SELECT a.id, (a.stressLevel + b.stressLevel + c.stressLevel) / 3
FROM pattern [ 
	every 	a=RoboticArm(status="goodGrasped") -> 
		  	b=RoboticArm(id = a.id, status="movingGood") ->
		  	c=RoboticArm(id = a.id, status="placingGood")  ];
```

### Q4

Declare a continuous query that returns the robotic arms that, 

* in less than 10 second,
* picked a good while safely operating,
* moved it while the controller was raising a warning, and
* placed it while safely operating again.

#### Solution

```
@Name("E4") 
insert into warning
SELECT a.id 
FROM pattern [ 
	every	a=RoboticArm(status="goodGrasped", stressLevel < 7) ->
			(
				b=RoboticArm(id = a.id, status="movingGood", stressLevel > 6 and stressLevel < 9) ->
				c=RoboticArm(id = a.id, status="placingGood", stressLevel < 7) 
			)
			where timer:within(10 seconds)
		] ;
```

### Q5

Declare a continuous query that monitors the results of the previous one (i.e., Q4) and counts how many times each robotic arm is present in the stream over a window of 10 seconds, updating the counting every 2 seconds.

#### Solution

```
@Name("Q5") 
select arm, count(*)
from warning.win:time(10 sec)
group by arm
output last every 2 sec;
```

## Bonus content

### relaxing assumptions

#### What if the arm does not send an event only when it changes the status?

for instance, it may report moving goods multiple times, such as in 

```
RoboticArm={id="1", status="ready", stressLevel=0} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="goodGrasped", stressLevel=1} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="movingGood", stressLevel=7} 
RoboticArm={id="2", status="ready", stressLevel=0} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="movingGood", stressLevel=7} 
RoboticArm={id="2", status="goodGrasped", stressLevel=5} 
t=t.plus(1 seconds) 
RoboticArm={id="2", status="movingGood", stressLevel=9} 
t=t.plus(5 seconds) 
RoboticArm={id="2", status="placingGood", stressLevel=3} 
RoboticArm={id="1", status="placingGood", stressLevel=3} 
t=t.plus(4 seconds) 
RoboticArm={id="1", status="moving", stressLevel=2} 
RoboticArm={id="2", status="moving", stressLevel=1} 
t=t.plus(3 seconds) 
RoboticArm={id="1", status="ready", stressLevel=0} 
RoboticArm={id="2", status="ready", stressLevel=0} 
t=t.plus(1 seconds)
```

Is the Q4 solution still valid? Shall we add a new `every` clause somewhere?

Adding `every` in front of `b=RoboticArm(id = a.id, status="movingGood", stressLevel > 6 and stressLevel < 9)` makes a difference

```
@Name("E4.every") 
insert into warning
SELECT a.id 
FROM pattern [ 
	every	a=RoboticArm(status="goodGrasped", stressLevel < 7) -> 
			(  
				every b=RoboticArm(id = a.id, status="movingGood", stressLevel > 6 and stressLevel < 9) ->
				c=RoboticArm(id = a.id, status="placingGood", stressLevel < 7) 
			)
			where timer:within(10 seconds)
		] ;
```

#### What if the control system sends stop events?

Let's make the alternative assumption that:

* The control system sends a stop event when an arm has a fault.
* The arms restart after a fault in the status they were before the fault. 

We declare an extra event type

```
create schema Stop( id string);
```

Hereafter, there is a data stream that contains `Stop` events, 

```
RoboticArm={id="1", status="ready", stressLevel=0} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="goodGrasped", stressLevel=1} 
t=t.plus(1 seconds) 
RoboticArm={id="1", status="movingGood", stressLevel=7} 
RoboticArm={id="2", status="ready", stressLevel=0} 
t=t.plus(1 seconds) 
RoboticArm={id="2", status="goodGrasped", stressLevel=5} 
t=t.plus(1 seconds) 
RoboticArm={id="2", status="movingGood", stressLevel=9} 
t=t.plus(2 seconds) 
Stop={id="1"}
t=t.plus(3 seconds) 
RoboticArm={id="2", status="placingGood", stressLevel=3} 
RoboticArm={id="1", status="placingGood", stressLevel=3} 
t=t.plus(4 seconds) 
RoboticArm={id="1", status="moving", stressLevel=2} 
RoboticArm={id="2", status="moving", stressLevel=1} 
t=t.plus(3 seconds) 
RoboticArm={id="1", status="ready", stressLevel=0} 
RoboticArm={id="2", status="ready", stressLevel=0} 
t=t.plus(1 seconds)
```

In that case, Q4 may be updated as follows to avoid creating a warning if the arm stops while moving.

```
@Name("Q4.andnot") 
insert into warning
SELECT a.id 
FROM pattern [ 
	every	a=RoboticArm(status="goodGrasped", stressLevel < 7) -> 
			(  every
				b=RoboticArm(id = a.id, status="movingGood", stressLevel > 6 and stressLevel < 9) ->
				c=RoboticArm(id = a.id, status="placingGood", stressLevel < 7) and not Stop(id = a.id)
			)
			where timer:within(10 seconds)
		] ;
```

NOTE: If you remove the Stop event, `E4.andnot` will match once. With the Stop event, it does not match.

